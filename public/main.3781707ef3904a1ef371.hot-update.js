"use strict";
self["webpackHotUpdateweb_experiment_1"]("main",{

/***/ "./shared/shaders/blob-vertex.glsl":
/*!*****************************************!*\
  !*** ./shared/shaders/blob-vertex.glsl ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#define GLSLIFY 1\nattribute vec4 tangent;\nattribute float pattern;\n\nvarying float vPattern;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uNoiseStrength;\nuniform float uDisplacementStrength;\nuniform float uFractAmount;\n\nconst float PI = 3.1415926535897932384626433832795;\n\n// Classic Perlin 3D Noise functions (Stefan Gustavson's implementation)\n// Permute, taylorInvSqrt, fade, cnoise functions go here...\n\nfloat cnoise(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nfloat smoothMod(float axis, float amp, float rad) {\n    float top = cos(PI * (axis / amp)) * sin(PI * (axis / amp));\n    float bottom = pow(sin(PI * (axis / amp)), 2.0) + pow(rad, 2.0);\n    float at = atan(top / bottom);\n    return amp * (0.5) - (1.0 / PI) * at;\n}\n\nfloat getDisplacement(vec3 position) {\n    vec3 pos = position;\n    pos.y -= uTime * 0.05 * uSpeed;\n    pos += cnoise(pos * 1.65) * uNoiseStrength;\n\n    return smoothMod(pos.y * uFractAmount, 1.0, 1.5) * uDisplacementStrength;\n}\n\nvoid main() {\n    vec3 biTangent = cross(normal, tangent.xyz);\n    float shift = 0.01;\n    vec3 posA = position + tangent.xyz * shift;\n    vec3 posB = position + biTangent * shift;\n\n    float displacement = getDisplacement(position);\n    vPattern = displacement;\n\n    position += normal * displacement;\n    posA += normal * getDisplacement(posA);\n    posB += normal * getDisplacement(posB);\n\n    vec3 toA = normalize(posA - position);\n    vec3 toB = normalize(posB - position);\n\n    normal = normalize(cross(toA, toB));\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("bcbf8af1b9a0db7e9783")
/******/ })();
/******/ 
/******/ }
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi4zNzgxNzA3ZWYzOTA0YTFlZjM3MS5ob3QtdXBkYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBZSwyQ0FBMkMsMEJBQTBCLDJCQUEyQix3QkFBd0IsdUJBQXVCLCtCQUErQixzQ0FBc0MsNkJBQTZCLHVEQUF1RCxvS0FBb0sseUJBQXlCLDREQUE0RCw2Q0FBNkMsMEJBQTBCLHlCQUF5QixvRUFBb0UsdUVBQXVFLG1DQUFtQyx3QkFBd0Isd0JBQXdCLDJDQUEyQyxtQ0FBbUMsbUNBQW1DLDRCQUE0Qiw2Q0FBNkMscUJBQXFCLCtDQUErQyxvQ0FBb0Msd0NBQXdDLHdDQUF3Qyw0QkFBNEIsNkNBQTZDLHFCQUFxQiwrQ0FBK0Msb0NBQW9DLHdDQUF3Qyx3Q0FBd0MsMENBQTBDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLHdDQUF3QywyR0FBMkcsb0JBQW9CLG9CQUFvQixvQkFBb0Isb0JBQW9CLHlHQUF5RyxvQkFBb0Isb0JBQW9CLG9CQUFvQixvQkFBb0Isa0NBQWtDLGdEQUFnRCxzREFBc0QsZ0RBQWdELGdEQUFnRCxzREFBc0QsZ0RBQWdELGdDQUFnQyxnQ0FBZ0MsMkZBQTJGLGdEQUFnRCxtREFBbUQsdUJBQXVCLEdBQUcsdURBQXVELGtFQUFrRSxzRUFBc0Usb0NBQW9DLDJDQUEyQyxHQUFHLDBDQUEwQywwQkFBMEIscUNBQXFDLGlEQUFpRCxpRkFBaUYsR0FBRyxpQkFBaUIsa0RBQWtELHlCQUF5QixpREFBaUQsK0NBQStDLHVEQUF1RCw4QkFBOEIsMENBQTBDLDZDQUE2Qyw2Q0FBNkMsOENBQThDLDRDQUE0Qyw0Q0FBNEMsK0VBQStFLEdBQUcsR0FBRzs7Ozs7Ozs7VUNBNTJIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWV4cGVyaW1lbnQtMS8uL3NoYXJlZC9zaGFkZXJzL2Jsb2ItdmVydGV4Lmdsc2wiLCJ3ZWJwYWNrOi8vd2ViLWV4cGVyaW1lbnQtMS93ZWJwYWNrL3J1bnRpbWUvZ2V0RnVsbEhhc2giXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XFxuYXR0cmlidXRlIGZsb2F0IHBhdHRlcm47XFxuXFxudmFyeWluZyBmbG9hdCB2UGF0dGVybjtcXG5cXG51bmlmb3JtIGZsb2F0IHVUaW1lO1xcbnVuaWZvcm0gZmxvYXQgdVNwZWVkO1xcbnVuaWZvcm0gZmxvYXQgdU5vaXNlU3RyZW5ndGg7XFxudW5pZm9ybSBmbG9hdCB1RGlzcGxhY2VtZW50U3RyZW5ndGg7XFxudW5pZm9ybSBmbG9hdCB1RnJhY3RBbW91bnQ7XFxuXFxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTU7XFxuXFxuLy8gQ2xhc3NpYyBQZXJsaW4gM0QgTm9pc2UgZnVuY3Rpb25zIChTdGVmYW4gR3VzdGF2c29uJ3MgaW1wbGVtZW50YXRpb24pXFxuLy8gUGVybXV0ZSwgdGF5bG9ySW52U3FydCwgZmFkZSwgY25vaXNlIGZ1bmN0aW9ucyBnbyBoZXJlLi4uXFxuXFxuZmxvYXQgY25vaXNlKHZlYzMgUCkge1xcbiAgdmVjMyBQaTAgPSBmbG9vcihQKTsgLy8gSW50ZWdlciBwYXJ0IGZvciBpbmRleGluZ1xcbiAgdmVjMyBQaTEgPSBQaTAgKyB2ZWMzKDEuMCk7IC8vIEludGVnZXIgcGFydCArIDFcXG4gIFBpMCA9IG1vZChQaTAsIDI4OS4wKTtcXG4gIFBpMSA9IG1vZChQaTEsIDI4OS4wKTtcXG4gIHZlYzMgUGYwID0gZnJhY3QoUCk7IC8vIEZyYWN0aW9uYWwgcGFydCBmb3IgaW50ZXJwb2xhdGlvblxcbiAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcbiAgdmVjNCBpeCA9IHZlYzQoUGkwLngsIFBpMS54LCBQaTAueCwgUGkxLngpO1xcbiAgdmVjNCBpeSA9IHZlYzQoUGkwLnl5LCBQaTEueXkpO1xcbiAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG4gIHZlYzQgaXoxID0gUGkxLnp6eno7XFxuXFxuICB2ZWM0IGl4eSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XFxuICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XFxuICB2ZWM0IGl4eTEgPSBwZXJtdXRlKGl4eSArIGl6MSk7XFxuXFxuICB2ZWM0IGd4MCA9IGl4eTAgLyA3LjA7XFxuICB2ZWM0IGd5MCA9IGZyYWN0KGZsb29yKGd4MCkgLyA3LjApIC0gMC41O1xcbiAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gIHZlYzQgZ3owID0gdmVjNCgwLjUpIC0gYWJzKGd4MCkgLSBhYnMoZ3kwKTtcXG4gIHZlYzQgc3owID0gc3RlcChnejAsIHZlYzQoMC4wKSk7XFxuICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG4gIGd5MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd5MCkgLSAwLjUpO1xcblxcbiAgdmVjNCBneDEgPSBpeHkxIC8gNy4wO1xcbiAgdmVjNCBneTEgPSBmcmFjdChmbG9vcihneDEpIC8gNy4wKSAtIDAuNTtcXG4gIGd4MSA9IGZyYWN0KGd4MSk7XFxuICB2ZWM0IGd6MSA9IHZlYzQoMC41KSAtIGFicyhneDEpIC0gYWJzKGd5MSk7XFxuICB2ZWM0IHN6MSA9IHN0ZXAoZ3oxLCB2ZWM0KDAuMCkpO1xcbiAgZ3gxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3gxKSAtIDAuNSk7XFxuICBneTEgLT0gc3oxICogKHN0ZXAoMC4wLCBneTEpIC0gMC41KTtcXG5cXG4gIHZlYzMgZzAwMCA9IHZlYzMoZ3gwLngsZ3kwLngsZ3owLngpO1xcbiAgdmVjMyBnMTAwID0gdmVjMyhneDAueSxneTAueSxnejAueSk7XFxuICB2ZWMzIGcwMTAgPSB2ZWMzKGd4MC56LGd5MC56LGd6MC56KTtcXG4gIHZlYzMgZzExMCA9IHZlYzMoZ3gwLncsZ3kwLncsZ3owLncpO1xcbiAgdmVjMyBnMDAxID0gdmVjMyhneDEueCxneTEueCxnejEueCk7XFxuICB2ZWMzIGcxMDEgPSB2ZWMzKGd4MS55LGd5MS55LGd6MS55KTtcXG4gIHZlYzMgZzAxMSA9IHZlYzMoZ3gxLnosZ3kxLnosZ3oxLnopO1xcbiAgdmVjMyBnMTExID0gdmVjMyhneDEudyxneTEudyxnejEudyk7XFxuXFxuICB2ZWM0IG5vcm0wID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAwLCBnMDAwKSwgZG90KGcwMTAsIGcwMTApLCBkb3QoZzEwMCwgZzEwMCksIGRvdChnMTEwLCBnMTEwKSkpO1xcbiAgZzAwMCAqPSBub3JtMC54O1xcbiAgZzAxMCAqPSBub3JtMC55O1xcbiAgZzEwMCAqPSBub3JtMC56O1xcbiAgZzExMCAqPSBub3JtMC53O1xcbiAgdmVjNCBub3JtMSA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMSwgZzAwMSksIGRvdChnMDExLCBnMDExKSwgZG90KGcxMDEsIGcxMDEpLCBkb3QoZzExMSwgZzExMSkpKTtcXG4gIGcwMDEgKj0gbm9ybTEueDtcXG4gIGcwMTEgKj0gbm9ybTEueTtcXG4gIGcxMDEgKj0gbm9ybTEuejtcXG4gIGcxMTEgKj0gbm9ybTEudztcXG5cXG4gIGZsb2F0IG4wMDAgPSBkb3QoZzAwMCwgUGYwKTtcXG4gIGZsb2F0IG4xMDAgPSBkb3QoZzEwMCwgdmVjMyhQZjEueCwgUGYwLnl6KSk7XFxuICBmbG9hdCBuMDEwID0gZG90KGcwMTAsIHZlYzMoUGYwLngsIFBmMS55LCBQZjAueikpO1xcbiAgZmxvYXQgbjExMCA9IGRvdChnMTEwLCB2ZWMzKFBmMS54eSwgUGYwLnopKTtcXG4gIGZsb2F0IG4wMDEgPSBkb3QoZzAwMSwgdmVjMyhQZjAueHksIFBmMS56KSk7XFxuICBmbG9hdCBuMTAxID0gZG90KGcxMDEsIHZlYzMoUGYxLngsIFBmMC55LCBQZjEueikpO1xcbiAgZmxvYXQgbjAxMSA9IGRvdChnMDExLCB2ZWMzKFBmMC54LCBQZjEueXopKTtcXG4gIGZsb2F0IG4xMTEgPSBkb3QoZzExMSwgUGYxKTtcXG5cXG4gIHZlYzMgZmFkZV94eXogPSBmYWRlKFBmMCk7XFxuICB2ZWM0IG5feiA9IG1peCh2ZWM0KG4wMDAsIG4xMDAsIG4wMTAsIG4xMTApLCB2ZWM0KG4wMDEsIG4xMDEsIG4wMTEsIG4xMTEpLCBmYWRlX3h5ei56KTtcXG4gIHZlYzIgbl95eiA9IG1peChuX3oueHksIG5fei56dywgZmFkZV94eXoueSk7XFxuICBmbG9hdCBuX3h5eiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7IFxcbiAgcmV0dXJuIDIuMiAqIG5feHl6O1xcbn1cXG5cXG5mbG9hdCBzbW9vdGhNb2QoZmxvYXQgYXhpcywgZmxvYXQgYW1wLCBmbG9hdCByYWQpIHtcXG4gICAgZmxvYXQgdG9wID0gY29zKFBJICogKGF4aXMgLyBhbXApKSAqIHNpbihQSSAqIChheGlzIC8gYW1wKSk7XFxuICAgIGZsb2F0IGJvdHRvbSA9IHBvdyhzaW4oUEkgKiAoYXhpcyAvIGFtcCkpLCAyLjApICsgcG93KHJhZCwgMi4wKTtcXG4gICAgZmxvYXQgYXQgPSBhdGFuKHRvcCAvIGJvdHRvbSk7XFxuICAgIHJldHVybiBhbXAgKiAoMC41KSAtICgxLjAgLyBQSSkgKiBhdDtcXG59XFxuXFxuZmxvYXQgZ2V0RGlzcGxhY2VtZW50KHZlYzMgcG9zaXRpb24pIHtcXG4gICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcXG4gICAgcG9zLnkgLT0gdVRpbWUgKiAwLjA1ICogdVNwZWVkO1xcbiAgICBwb3MgKz0gY25vaXNlKHBvcyAqIDEuNjUpICogdU5vaXNlU3RyZW5ndGg7XFxuXFxuICAgIHJldHVybiBzbW9vdGhNb2QocG9zLnkgKiB1RnJhY3RBbW91bnQsIDEuMCwgMS41KSAqIHVEaXNwbGFjZW1lbnRTdHJlbmd0aDtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMzIGJpVGFuZ2VudCA9IGNyb3NzKG5vcm1hbCwgdGFuZ2VudC54eXopO1xcbiAgICBmbG9hdCBzaGlmdCA9IDAuMDE7XFxuICAgIHZlYzMgcG9zQSA9IHBvc2l0aW9uICsgdGFuZ2VudC54eXogKiBzaGlmdDtcXG4gICAgdmVjMyBwb3NCID0gcG9zaXRpb24gKyBiaVRhbmdlbnQgKiBzaGlmdDtcXG5cXG4gICAgZmxvYXQgZGlzcGxhY2VtZW50ID0gZ2V0RGlzcGxhY2VtZW50KHBvc2l0aW9uKTtcXG4gICAgdlBhdHRlcm4gPSBkaXNwbGFjZW1lbnQ7XFxuXFxuICAgIHBvc2l0aW9uICs9IG5vcm1hbCAqIGRpc3BsYWNlbWVudDtcXG4gICAgcG9zQSArPSBub3JtYWwgKiBnZXREaXNwbGFjZW1lbnQocG9zQSk7XFxuICAgIHBvc0IgKz0gbm9ybWFsICogZ2V0RGlzcGxhY2VtZW50KHBvc0IpO1xcblxcbiAgICB2ZWMzIHRvQSA9IG5vcm1hbGl6ZShwb3NBIC0gcG9zaXRpb24pO1xcbiAgICB2ZWMzIHRvQiA9IG5vcm1hbGl6ZShwb3NCIC0gcG9zaXRpb24pO1xcblxcbiAgICBub3JtYWwgPSBub3JtYWxpemUoY3Jvc3ModG9BLCB0b0IpKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XFxuXCI7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5oID0gKCkgPT4gKFwiYmNiZjhhZjFiOWEwZGI3ZTk3ODNcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=