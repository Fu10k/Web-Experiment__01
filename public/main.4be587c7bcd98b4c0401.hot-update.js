"use strict";
self["webpackHotUpdateweb_experiment_1"]("main",{

/***/ "./shared/shaders/blob-vertex.glsl":
/*!*****************************************!*\
  !*** ./shared/shaders/blob-vertex.glsl ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#define GLSLIFY 1\nuniform float uTime;\n\nvarying float vPattern;\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson (https://github.com/stegu/webgl-noise)\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// It's like mod() function, but \"smooth\" (thank you, captain!), with no immediate jump to 0\nfloat smoothMod(float axis, float amp, float rad) {\n    float top = cos(PI * (axis / amp)) * sin(PI * (axis / amp));\n    float bottom = pow(sin(PI * (axis / amp)), 2.0) + pow(rad, 2.0);\n    float at = atan(top / bottom);\n    return amp * (1.0 / 2.0) - (1.0 / PI) * at;\n}\n\n// We gonna use this function multiple times\nfloat getDisplacement(vec3 position) {\n\t\t// gonna be uniforms later on\n\t\tfloat uFractAmount = 4.;\n\t\tfloat uDisplacementStrength = 0.57;\n\t\tfloat uSpeed = 1.1;\n\n    vec3 pos = position;\n    pos.y -= uTime * 0.05 * uSpeed; // pattern changes in time, going up\n    pos += cnoise(pos * 1.65) * uNoiseStrength; // position distortion with noise\n\n    return smoothMod(pos.y * uFractAmount, 1., 1.5) * uDisplacementStrength;\n}\n\nvoid main() {\n    float pattern = getDisplacement(position);\n    vPattern = pattern; // pass the result to the fragment shader\n}");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("6021cece7ac7ae0f3bda")
/******/ })();
/******/ 
/******/ }
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi40YmU1ODdjN2JjZDk4YjRjMDQwMS5ob3QtdXBkYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBZSx3Q0FBd0MsMkJBQTJCLDJIQUEySCxxQ0FBcUMsNkJBQTZCLGdEQUFnRCxxQkFBcUIsb0NBQW9DLHlCQUF5Qix5QkFBeUIsNERBQTRELDZDQUE2QywwQkFBMEIseUJBQXlCLG9FQUFvRSx1RUFBdUUsbUNBQW1DLHdCQUF3Qix3QkFBd0IsMkNBQTJDLG1DQUFtQyxtQ0FBbUMsNEJBQTRCLDZDQUE2QyxxQkFBcUIsK0NBQStDLG9DQUFvQyx3Q0FBd0Msd0NBQXdDLDRCQUE0Qiw2Q0FBNkMscUJBQXFCLCtDQUErQyxvQ0FBb0Msd0NBQXdDLHdDQUF3QywwQ0FBMEMsd0NBQXdDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLHdDQUF3Qyx3Q0FBd0Msd0NBQXdDLDJHQUEyRyxvQkFBb0Isb0JBQW9CLG9CQUFvQixvQkFBb0IseUdBQXlHLG9CQUFvQixvQkFBb0Isb0JBQW9CLG9CQUFvQixrQ0FBa0MsZ0RBQWdELHNEQUFzRCxnREFBZ0QsZ0RBQWdELHNEQUFzRCxnREFBZ0QsZ0NBQWdDLGdDQUFnQywyRkFBMkYsZ0RBQWdELG1EQUFtRCx1QkFBdUIsR0FBRyx1SkFBdUosa0VBQWtFLHNFQUFzRSxvQ0FBb0MsaURBQWlELEdBQUcsd0ZBQXdGLGlFQUFpRSx5Q0FBeUMseUJBQXlCLDRCQUE0QixzQ0FBc0Msc0ZBQXNGLGlIQUFpSCxHQUFHLGlCQUFpQixnREFBZ0QsMEJBQTBCLDRDQUE0QyxDQUFDOzs7Ozs7OztVQ0F6cEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItZXhwZXJpbWVudC0xLy4vc2hhcmVkL3NoYWRlcnMvYmxvYi12ZXJ0ZXguZ2xzbCIsIndlYnBhY2s6Ly93ZWItZXhwZXJpbWVudC0xL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG5cXG52YXJ5aW5nIGZsb2F0IHZQYXR0ZXJuO1xcblxcbi8vXFx0Q2xhc3NpYyBQZXJsaW4gM0QgTm9pc2UgXFxuLy9cXHRieSBTdGVmYW4gR3VzdGF2c29uIChodHRwczovL2dpdGh1Yi5jb20vc3RlZ3Uvd2ViZ2wtbm9pc2UpXFxuLy9cXG52ZWM0IHBlcm11dGUodmVjNCB4KXtyZXR1cm4gbW9kKCgoeCozNC4wKSsxLjApKngsIDI4OS4wKTt9XFxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcil7cmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjt9XFxudmVjMyBmYWRlKHZlYzMgdCkge3JldHVybiB0KnQqdCoodCoodCo2LjAtMTUuMCkrMTAuMCk7fVxcblxcbmZsb2F0IGNub2lzZSh2ZWMzIFApe1xcbiAgdmVjMyBQaTAgPSBmbG9vcihQKTsgLy8gSW50ZWdlciBwYXJ0IGZvciBpbmRleGluZ1xcbiAgdmVjMyBQaTEgPSBQaTAgKyB2ZWMzKDEuMCk7IC8vIEludGVnZXIgcGFydCArIDFcXG4gIFBpMCA9IG1vZChQaTAsIDI4OS4wKTtcXG4gIFBpMSA9IG1vZChQaTEsIDI4OS4wKTtcXG4gIHZlYzMgUGYwID0gZnJhY3QoUCk7IC8vIEZyYWN0aW9uYWwgcGFydCBmb3IgaW50ZXJwb2xhdGlvblxcbiAgdmVjMyBQZjEgPSBQZjAgLSB2ZWMzKDEuMCk7IC8vIEZyYWN0aW9uYWwgcGFydCAtIDEuMFxcbiAgdmVjNCBpeCA9IHZlYzQoUGkwLngsIFBpMS54LCBQaTAueCwgUGkxLngpO1xcbiAgdmVjNCBpeSA9IHZlYzQoUGkwLnl5LCBQaTEueXkpO1xcbiAgdmVjNCBpejAgPSBQaTAuenp6ejtcXG4gIHZlYzQgaXoxID0gUGkxLnp6eno7XFxuXFxuICB2ZWM0IGl4eSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XFxuICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XFxuICB2ZWM0IGl4eTEgPSBwZXJtdXRlKGl4eSArIGl6MSk7XFxuXFxuICB2ZWM0IGd4MCA9IGl4eTAgLyA3LjA7XFxuICB2ZWM0IGd5MCA9IGZyYWN0KGZsb29yKGd4MCkgLyA3LjApIC0gMC41O1xcbiAgZ3gwID0gZnJhY3QoZ3gwKTtcXG4gIHZlYzQgZ3owID0gdmVjNCgwLjUpIC0gYWJzKGd4MCkgLSBhYnMoZ3kwKTtcXG4gIHZlYzQgc3owID0gc3RlcChnejAsIHZlYzQoMC4wKSk7XFxuICBneDAgLT0gc3owICogKHN0ZXAoMC4wLCBneDApIC0gMC41KTtcXG4gIGd5MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd5MCkgLSAwLjUpO1xcblxcbiAgdmVjNCBneDEgPSBpeHkxIC8gNy4wO1xcbiAgdmVjNCBneTEgPSBmcmFjdChmbG9vcihneDEpIC8gNy4wKSAtIDAuNTtcXG4gIGd4MSA9IGZyYWN0KGd4MSk7XFxuICB2ZWM0IGd6MSA9IHZlYzQoMC41KSAtIGFicyhneDEpIC0gYWJzKGd5MSk7XFxuICB2ZWM0IHN6MSA9IHN0ZXAoZ3oxLCB2ZWM0KDAuMCkpO1xcbiAgZ3gxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3gxKSAtIDAuNSk7XFxuICBneTEgLT0gc3oxICogKHN0ZXAoMC4wLCBneTEpIC0gMC41KTtcXG5cXG4gIHZlYzMgZzAwMCA9IHZlYzMoZ3gwLngsZ3kwLngsZ3owLngpO1xcbiAgdmVjMyBnMTAwID0gdmVjMyhneDAueSxneTAueSxnejAueSk7XFxuICB2ZWMzIGcwMTAgPSB2ZWMzKGd4MC56LGd5MC56LGd6MC56KTtcXG4gIHZlYzMgZzExMCA9IHZlYzMoZ3gwLncsZ3kwLncsZ3owLncpO1xcbiAgdmVjMyBnMDAxID0gdmVjMyhneDEueCxneTEueCxnejEueCk7XFxuICB2ZWMzIGcxMDEgPSB2ZWMzKGd4MS55LGd5MS55LGd6MS55KTtcXG4gIHZlYzMgZzAxMSA9IHZlYzMoZ3gxLnosZ3kxLnosZ3oxLnopO1xcbiAgdmVjMyBnMTExID0gdmVjMyhneDEudyxneTEudyxnejEudyk7XFxuXFxuICB2ZWM0IG5vcm0wID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAwLCBnMDAwKSwgZG90KGcwMTAsIGcwMTApLCBkb3QoZzEwMCwgZzEwMCksIGRvdChnMTEwLCBnMTEwKSkpO1xcbiAgZzAwMCAqPSBub3JtMC54O1xcbiAgZzAxMCAqPSBub3JtMC55O1xcbiAgZzEwMCAqPSBub3JtMC56O1xcbiAgZzExMCAqPSBub3JtMC53O1xcbiAgdmVjNCBub3JtMSA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMSwgZzAwMSksIGRvdChnMDExLCBnMDExKSwgZG90KGcxMDEsIGcxMDEpLCBkb3QoZzExMSwgZzExMSkpKTtcXG4gIGcwMDEgKj0gbm9ybTEueDtcXG4gIGcwMTEgKj0gbm9ybTEueTtcXG4gIGcxMDEgKj0gbm9ybTEuejtcXG4gIGcxMTEgKj0gbm9ybTEudztcXG5cXG4gIGZsb2F0IG4wMDAgPSBkb3QoZzAwMCwgUGYwKTtcXG4gIGZsb2F0IG4xMDAgPSBkb3QoZzEwMCwgdmVjMyhQZjEueCwgUGYwLnl6KSk7XFxuICBmbG9hdCBuMDEwID0gZG90KGcwMTAsIHZlYzMoUGYwLngsIFBmMS55LCBQZjAueikpO1xcbiAgZmxvYXQgbjExMCA9IGRvdChnMTEwLCB2ZWMzKFBmMS54eSwgUGYwLnopKTtcXG4gIGZsb2F0IG4wMDEgPSBkb3QoZzAwMSwgdmVjMyhQZjAueHksIFBmMS56KSk7XFxuICBmbG9hdCBuMTAxID0gZG90KGcxMDEsIHZlYzMoUGYxLngsIFBmMC55LCBQZjEueikpO1xcbiAgZmxvYXQgbjAxMSA9IGRvdChnMDExLCB2ZWMzKFBmMC54LCBQZjEueXopKTtcXG4gIGZsb2F0IG4xMTEgPSBkb3QoZzExMSwgUGYxKTtcXG5cXG4gIHZlYzMgZmFkZV94eXogPSBmYWRlKFBmMCk7XFxuICB2ZWM0IG5feiA9IG1peCh2ZWM0KG4wMDAsIG4xMDAsIG4wMTAsIG4xMTApLCB2ZWM0KG4wMDEsIG4xMDEsIG4wMTEsIG4xMTEpLCBmYWRlX3h5ei56KTtcXG4gIHZlYzIgbl95eiA9IG1peChuX3oueHksIG5fei56dywgZmFkZV94eXoueSk7XFxuICBmbG9hdCBuX3h5eiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7IFxcbiAgcmV0dXJuIDIuMiAqIG5feHl6O1xcbn1cXG5cXG4vLyBJdCdzIGxpa2UgbW9kKCkgZnVuY3Rpb24sIGJ1dCBcXFwic21vb3RoXFxcIiAodGhhbmsgeW91LCBjYXB0YWluISksIHdpdGggbm8gaW1tZWRpYXRlIGp1bXAgdG8gMFxcbmZsb2F0IHNtb290aE1vZChmbG9hdCBheGlzLCBmbG9hdCBhbXAsIGZsb2F0IHJhZCkge1xcbiAgICBmbG9hdCB0b3AgPSBjb3MoUEkgKiAoYXhpcyAvIGFtcCkpICogc2luKFBJICogKGF4aXMgLyBhbXApKTtcXG4gICAgZmxvYXQgYm90dG9tID0gcG93KHNpbihQSSAqIChheGlzIC8gYW1wKSksIDIuMCkgKyBwb3cocmFkLCAyLjApO1xcbiAgICBmbG9hdCBhdCA9IGF0YW4odG9wIC8gYm90dG9tKTtcXG4gICAgcmV0dXJuIGFtcCAqICgxLjAgLyAyLjApIC0gKDEuMCAvIFBJKSAqIGF0O1xcbn1cXG5cXG4vLyBXZSBnb25uYSB1c2UgdGhpcyBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lc1xcbmZsb2F0IGdldERpc3BsYWNlbWVudCh2ZWMzIHBvc2l0aW9uKSB7XFxuXFx0XFx0Ly8gZ29ubmEgYmUgdW5pZm9ybXMgbGF0ZXIgb25cXG5cXHRcXHRmbG9hdCB1RnJhY3RBbW91bnQgPSA0LjtcXG5cXHRcXHRmbG9hdCB1RGlzcGxhY2VtZW50U3RyZW5ndGggPSAwLjU3O1xcblxcdFxcdGZsb2F0IHVTcGVlZCA9IDEuMTtcXG5cXG4gICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcXG4gICAgcG9zLnkgLT0gdVRpbWUgKiAwLjA1ICogdVNwZWVkOyAvLyBwYXR0ZXJuIGNoYW5nZXMgaW4gdGltZSwgZ29pbmcgdXBcXG4gICAgcG9zICs9IGNub2lzZShwb3MgKiAxLjY1KSAqIHVOb2lzZVN0cmVuZ3RoOyAvLyBwb3NpdGlvbiBkaXN0b3J0aW9uIHdpdGggbm9pc2VcXG5cXG4gICAgcmV0dXJuIHNtb290aE1vZChwb3MueSAqIHVGcmFjdEFtb3VudCwgMS4sIDEuNSkgKiB1RGlzcGxhY2VtZW50U3RyZW5ndGg7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZmxvYXQgcGF0dGVybiA9IGdldERpc3BsYWNlbWVudChwb3NpdGlvbik7XFxuICAgIHZQYXR0ZXJuID0gcGF0dGVybjsgLy8gcGFzcyB0aGUgcmVzdWx0IHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXG59XCI7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5oID0gKCkgPT4gKFwiNjAyMWNlY2U3YWM3YWUwZjNiZGFcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=