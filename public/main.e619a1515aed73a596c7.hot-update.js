"use strict";
self["webpackHotUpdateweb_experiment_1"]("main",{

/***/ "./shared/shaders/blob-vertex.glsl":
/*!*****************************************!*\
  !*** ./shared/shaders/blob-vertex.glsl ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#define GLSLIFY 1\nattribute vec4 tangent;\nattribute float pattern;\n\nvarying float vPattern;\n\nuniform float uTime;\nuniform float uSpeed;\nuniform float uNoiseStrength;\nuniform float uDisplacementStrength;\nuniform float uFractAmount;\n\nconst float PI = 3.1415926535897932384626433832795;\n\n// Classic Perlin 3D Noise functions (Stefan Gustavson's implementation)\n// Permute, taylorInvSqrt, fade, cnoise functions go here...\n\nfloat cnoise(vec3 P) {\n    // Implementation of 3D Perlin noise (as provided)\n    // Make sure this function is copied correctly from your original source\n    // and adapted as necessary for GLSL ES compatibility.\n}\n\nfloat smoothMod(float axis, float amp, float rad) {\n    float top = cos(PI * (axis / amp)) * sin(PI * (axis / amp));\n    float bottom = pow(sin(PI * (axis / amp)), 2.0) + pow(rad, 2.0);\n    float at = atan(top / bottom);\n    return amp * (0.5) - (1.0 / PI) * at;\n}\n\nfloat getDisplacement(vec3 position) {\n    vec3 pos = position;\n    pos.y -= uTime * 0.05 * uSpeed;\n    pos += cnoise(pos * 1.65) * uNoiseStrength;\n\n    return smoothMod(pos.y * uFractAmount, 1.0, 1.5) * uDisplacementStrength;\n}\n\nvoid main() {\n    vec3 biTangent = cross(normal, tangent.xyz);\n    float shift = 0.01;\n    vec3 posA = position + tangent.xyz * shift;\n    vec3 posB = position + biTangent * shift;\n\n    float displacement = getDisplacement(position);\n    vPattern = displacement;\n\n    position += normal * displacement;\n    posA += normal * getDisplacement(posA);\n    posB += normal * getDisplacement(posB);\n\n    vec3 toA = normalize(posA - position);\n    vec3 toB = normalize(posB - position);\n\n    normal = normalize(cross(toA, toB));\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("3781707ef3904a1ef371")
/******/ })();
/******/ 
/******/ }
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5lNjE5YTE1MTVhZWQ3M2E1OTZjNy5ob3QtdXBkYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBZSwyQ0FBMkMsMEJBQTBCLDJCQUEyQix3QkFBd0IsdUJBQXVCLCtCQUErQixzQ0FBc0MsNkJBQTZCLHVEQUF1RCxvS0FBb0sscU1BQXFNLHVEQUF1RCxrRUFBa0Usc0VBQXNFLG9DQUFvQywyQ0FBMkMsR0FBRywwQ0FBMEMsMEJBQTBCLHFDQUFxQyxpREFBaUQsaUZBQWlGLEdBQUcsaUJBQWlCLGtEQUFrRCx5QkFBeUIsaURBQWlELCtDQUErQyx1REFBdUQsOEJBQThCLDBDQUEwQyw2Q0FBNkMsNkNBQTZDLDhDQUE4Qyw0Q0FBNEMsNENBQTRDLCtFQUErRSxHQUFHLEdBQUc7Ozs7Ozs7O1VDQS93RCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1leHBlcmltZW50LTEvLi9zaGFyZWQvc2hhZGVycy9ibG9iLXZlcnRleC5nbHNsIiwid2VicGFjazovL3dlYi1leHBlcmltZW50LTEvd2VicGFjay9ydW50aW1lL2dldEZ1bGxIYXNoIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjNCB0YW5nZW50O1xcbmF0dHJpYnV0ZSBmbG9hdCBwYXR0ZXJuO1xcblxcbnZhcnlpbmcgZmxvYXQgdlBhdHRlcm47XFxuXFxudW5pZm9ybSBmbG9hdCB1VGltZTtcXG51bmlmb3JtIGZsb2F0IHVTcGVlZDtcXG51bmlmb3JtIGZsb2F0IHVOb2lzZVN0cmVuZ3RoO1xcbnVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudFN0cmVuZ3RoO1xcbnVuaWZvcm0gZmxvYXQgdUZyYWN0QW1vdW50O1xcblxcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O1xcblxcbi8vIENsYXNzaWMgUGVybGluIDNEIE5vaXNlIGZ1bmN0aW9ucyAoU3RlZmFuIEd1c3RhdnNvbidzIGltcGxlbWVudGF0aW9uKVxcbi8vIFBlcm11dGUsIHRheWxvckludlNxcnQsIGZhZGUsIGNub2lzZSBmdW5jdGlvbnMgZ28gaGVyZS4uLlxcblxcbmZsb2F0IGNub2lzZSh2ZWMzIFApIHtcXG4gICAgLy8gSW1wbGVtZW50YXRpb24gb2YgM0QgUGVybGluIG5vaXNlIChhcyBwcm92aWRlZClcXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgZnVuY3Rpb24gaXMgY29waWVkIGNvcnJlY3RseSBmcm9tIHlvdXIgb3JpZ2luYWwgc291cmNlXFxuICAgIC8vIGFuZCBhZGFwdGVkIGFzIG5lY2Vzc2FyeSBmb3IgR0xTTCBFUyBjb21wYXRpYmlsaXR5Llxcbn1cXG5cXG5mbG9hdCBzbW9vdGhNb2QoZmxvYXQgYXhpcywgZmxvYXQgYW1wLCBmbG9hdCByYWQpIHtcXG4gICAgZmxvYXQgdG9wID0gY29zKFBJICogKGF4aXMgLyBhbXApKSAqIHNpbihQSSAqIChheGlzIC8gYW1wKSk7XFxuICAgIGZsb2F0IGJvdHRvbSA9IHBvdyhzaW4oUEkgKiAoYXhpcyAvIGFtcCkpLCAyLjApICsgcG93KHJhZCwgMi4wKTtcXG4gICAgZmxvYXQgYXQgPSBhdGFuKHRvcCAvIGJvdHRvbSk7XFxuICAgIHJldHVybiBhbXAgKiAoMC41KSAtICgxLjAgLyBQSSkgKiBhdDtcXG59XFxuXFxuZmxvYXQgZ2V0RGlzcGxhY2VtZW50KHZlYzMgcG9zaXRpb24pIHtcXG4gICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcXG4gICAgcG9zLnkgLT0gdVRpbWUgKiAwLjA1ICogdVNwZWVkO1xcbiAgICBwb3MgKz0gY25vaXNlKHBvcyAqIDEuNjUpICogdU5vaXNlU3RyZW5ndGg7XFxuXFxuICAgIHJldHVybiBzbW9vdGhNb2QocG9zLnkgKiB1RnJhY3RBbW91bnQsIDEuMCwgMS41KSAqIHVEaXNwbGFjZW1lbnRTdHJlbmd0aDtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMzIGJpVGFuZ2VudCA9IGNyb3NzKG5vcm1hbCwgdGFuZ2VudC54eXopO1xcbiAgICBmbG9hdCBzaGlmdCA9IDAuMDE7XFxuICAgIHZlYzMgcG9zQSA9IHBvc2l0aW9uICsgdGFuZ2VudC54eXogKiBzaGlmdDtcXG4gICAgdmVjMyBwb3NCID0gcG9zaXRpb24gKyBiaVRhbmdlbnQgKiBzaGlmdDtcXG5cXG4gICAgZmxvYXQgZGlzcGxhY2VtZW50ID0gZ2V0RGlzcGxhY2VtZW50KHBvc2l0aW9uKTtcXG4gICAgdlBhdHRlcm4gPSBkaXNwbGFjZW1lbnQ7XFxuXFxuICAgIHBvc2l0aW9uICs9IG5vcm1hbCAqIGRpc3BsYWNlbWVudDtcXG4gICAgcG9zQSArPSBub3JtYWwgKiBnZXREaXNwbGFjZW1lbnQocG9zQSk7XFxuICAgIHBvc0IgKz0gbm9ybWFsICogZ2V0RGlzcGxhY2VtZW50KHBvc0IpO1xcblxcbiAgICB2ZWMzIHRvQSA9IG5vcm1hbGl6ZShwb3NBIC0gcG9zaXRpb24pO1xcbiAgICB2ZWMzIHRvQiA9IG5vcm1hbGl6ZShwb3NCIC0gcG9zaXRpb24pO1xcblxcbiAgICBub3JtYWwgPSBub3JtYWxpemUoY3Jvc3ModG9BLCB0b0IpKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XFxuXCI7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5oID0gKCkgPT4gKFwiMzc4MTcwN2VmMzkwNGExZWYzNzFcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=